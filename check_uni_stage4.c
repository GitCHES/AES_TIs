//check whether the input of the gf2^4 multiplier in TI2 stage 4 satisfy the uniformity
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
//F2^4 multiplier
int mul(int x, int y) {
	int w;
	int a[4],b[4],c[4];
	a[0]=(x & 0x8) >> 3;
	a[1]=(x & 0x4) >> 2;
	a[2]=(x & 0x2) >> 1;
	a[3]=x & 0x1;
	b[0]=(y & 0x8) >> 3;
	b[1]=(y & 0x4) >> 2;
	b[2]=(y & 0x2) >> 1;
	b[3]=y & 0x1;
	c[0]=(a[0]&b[0])^(a[2]&b[0])^(a[3]&b[0])^(a[1]&b[1])^(a[2]&b[1])^(a[0]&b[2])^(a[1]&b[2])^(a[2]&b[2])^(a[3]&b[2])^(a[0]&b[3])^(a[2]&b[3]);
	c[1]=(a[1]&b[0])^(a[2]&b[0])^(a[0]&b[1])^(a[1]&b[1])^(a[3]&b[1])^(a[0]&b[2])^(a[2]&b[2])^(a[1]&b[3])^(a[3]&b[3]);
	c[2]=(a[0]&b[0])^(a[1]&b[0])^(a[2]&b[0])^(a[3]&b[0])^(a[0]&b[1])^(a[2]&b[1])^(a[0]&b[2])^(a[1]&b[2])^(a[2]&b[2])^(a[0]&b[3])^(a[3]&b[3]);
	c[3]=(a[0]&b[0])^(a[2]&b[0])^(a[1]&b[1])^(a[3]&b[1])^(a[0]&b[2])^(a[3]&b[2])^(a[1]&b[3])^(a[2]&b[3])^(a[3]&b[3]);
	w=c[0]<<3|c[1]<<2|c[2]<<1|c[3];
	return ( w);
}
//the first stage of gf2^4 inverter
int inv11( int x[] ,int y[],int z[]) {
	int w;
	w=((x[1]^x[2]^x[3])&(y[1]^y[2]^y[3])&(z[1]^z[2]^z[3])) ^((x[1]^x[2]^x[3])&(y[1]^y[2]^y[3]))^z[1];
	return ( w);
}
int inv12( int x[] ,int y[],int z[]) {
	int w;
	w=(x[0]&y[0]&z[1])^(x[0]&y[1]&z[0])^(x[1]&y[0]&z[0])^(x[0]&y[1]&z[1])^(x[1]&y[0]&z[1])^(x[1]&y[1]&z[0])^(x[0]&y[1]&z[3])^(x[1]&y[0]&z[3])^(x[0]&y[3]&z[1])^(x[1]&y[3]&z[0])^(x[3]&y[0]&z[1])^(x[3]&y[1]&z[0])^(x[0]&y[1])^(x[1]&y[0])^z[3];
	return ( w);
}
//the second stage of gf2^4 inverter
int inv21( int x[] ,int y[],int z[]) {
	int w;
	w=(x[0]&(y[2]^y[3])&(z[2]^z[3]))^(y[0]&(x[2]^x[3])&(z[2]^z[3]))^(z[0]&(x[2]^x[3])&(y[2]^y[3]))^(x[0]&y[0]&(z[2]^z[3]))^(x[0]&z[0]&(y[2]^y[3]))^(y[0]&z[0]&(x[2]^x[3]))^(x[0]&y[0]&z[0])^(x[0]&(y[2]^y[3]))^(y[0]&(x[2]^x[3]))^(x[0]&y[0]) ^z[2];
	return ( w);
}
int inv22( int x[] ,int y[],int z[]) {
	int w;
	w=(x[0]&y[1]&z[2])^(x[0]&y[2]&z[1])^(x[1]&y[0]&z[2])^(x[1]&y[2]&z[0])^(x[2]&y[0]&z[1])^(x[2]&y[1]&z[0])^z[0];
	return ( w);
}
//check whether the sharing of Muls function(gf2^4 multiplier xor gf2^4 square scalar) satisfy the uniformity, where the Muls function is expressed in gf2
int main () {
	int a[4], b[4], c[4], d[4], e[4],f[4], p[4], q[4];//each bit of the 8-bit input has 4 shares
	int g1[4],g2[4],g3[4],g4[4];//output of the Muls in stage1
	int h11[2],h12[2],h13[2],h14[2];//output of the first stage of the inverter
	int h21[2],h22[2],h23[2],h24[2];//output of the second stage of the inverter
	int h[2],u[2],v[2],y1[4],y2[4],y[2];
	int i,j,z,r1,r2;
	int s1,s2,s3,s4,s5,s6,s7,s8;
	int tt[65536];//store the the number of times that a output y1,y2,y3,y4 occurs for any given input, all possible 2^(4*4) outputs
	int m,n;
	int o[4];
	//4 bit 0000
	for (i = 0; i< 4; i++) {
		o[i]=0;
	}
	for (m = 0; m< 16; m++) {
		for (n = 0; n< 16; n++) {	//the input (m,n), together 8 bits
			z=0;
			memset(tt,0,sizeof(tt));
			for (s1 = 0; s1< 8; s1++) {
				for ( s2 = 0;  s2< 8;  s2++) {
					for ( s3 = 0;  s3<8;  s3++) {
						for ( s4 = 0;  s4< 8;  s4++) {
							for ( s5 = 0;  s5<8 ;  s5++) {
								for ( s6 = 0;  s6< 8;  s6++) {
									for ( s7 = 0;  s7< 8;  s7++) {
										for (s8 = 0; s8< 8; s8++) {

											//each bit is divided into 4 shares by adding 3 random bits
											a[0]=(s1 & 0x4) >> 2;
											a[1]=(s1 & 0x2) >> 1 ;
											a[2]=s1 & 0x1;
											a[3] =((m & 0x8) >>3)^a[0]^a[1]^a[2];
											b[0]=(s2 & 0x4) >> 2;
											b[1]=(s2 & 0x2) >> 1 ;
											b[2]=s2 & 0x1;
											b[3] =((m & 0x4) >>2) ^b[0]^b[1]^b[2];
											c[0]=(s3 & 0x4) >> 2;
											c[1]=(s3 & 0x2) >> 1;
											c[2]=s3 & 0x1;
											c[3] =((m & 0x2) >>1) ^c[0]^c[1]^c[2];
											d[0]=(s4& 0x4) >> 2;
											d[1]=(s4& 0x2) >> 1 ;
											d[2]=s4& 0x1;
											d[3] =(m & 0x1) ^d[0]^d[1]^d[2];

											e[0]=(s5 & 0x4) >> 2;
											e[1]=(s5 & 0x2) >> 1;
											e[2]=s5 & 0x1;
											e[3] =((n & 0x8) >>3)  ^e[0]^e[1]^e[2];
											f[0]=(s6 & 0x4) >> 2;
											f[1]=(s6 & 0x2) >> 1;
											f[2]=s6 & 0x1;
											f[3] =((n & 0x4) >>2)^f[0]^f[1]^f[2];
											p[0]=(s7 & 0x4) >> 2;
											p[1]=(s7 & 0x2) >> 1;
											p[2]=s7 & 0x1;
											p[3] =((n & 0x2) >>1)^p[0]^p[1]^p[2];
											q[0]=(s8 & 0x4) >> 2;
											q[1]=(s8 & 0x2) >> 1;
											q[2]=s8 & 0x1;
											q[3] =(n & 0x1) ^q[0]^q[1]^q[2];

											//the sharing of Muls function(gf2^4 multiplier xor gf2^4 square scalar)
											g1[0]=(a[2]^a[3])&(e[1]^e[2])^(c[2]^c[3])&(e[1]^e[2])^(d[2]^d[3])&(e[1]^e[2])
											      ^(b[2]^b[3])&(f[1]^f[2])^(c[2]^c[3])&(f[1]^f[2])^(a[2]^a[3])&(p[1]^p[2])
											      ^(b[2]^b[3])&(p[1]^p[2])^(c[2]^c[3])&(p[1]^p[2])^(d[2]^d[3])&(p[1]^p[2])
											      ^(a[2]^a[3])&(q[1]^q[2])^(c[2]^c[3])&(q[1]^q[2])^b[1]^f[1]^d[1]^q[1];
											g2[0]=(b[2]^b[3])&(e[1]^e[2])^(c[2]^c[3])&(e[1]^e[2])^(a[2]^a[3])&(f[1]^f[2])
											      ^(b[2]^b[3])&(f[1]^f[2])^(d[2]^d[3])&(f[1]^f[2])^(a[2]^a[3])&(p[1]^p[2])
											      ^(c[2]^c[3])&(p[1]^p[2])^(b[2]^b[3])&(q[1]^q[2])^(d[2]^d[3])&(q[1]^q[2])^a[1]^e[1]
											      ^c[1]^p[1];
											g3[0]=(a[2]^a[3])&(e[1]^e[2])^(b[2]^b[3])&(e[1]^e[2])^(c[2]^c[3])&(e[1]^e[2])
											      ^(d[2]^d[3])&(e[1]^e[2])^(a[2]^a[3])&(f[1]^f[2])^(c[2]^c[3])&(f[1]^f[2])
											      ^(a[2]^a[3])&(p[1]^p[2])^(b[2]^b[3])&(p[1]^p[2])^(c[2]^c[3])&(p[1]^p[2])
											      ^(a[2]^a[3])&(q[1]^q[2])^(d[2]^d[3])&(q[1]^q[2])^c[1]^p[1]^d[1]^q[1];
											g4[0]=(a[2]^a[3])&(e[1]^e[2])^(c[2]^c[3])&(e[1]^e[2])^(b[2]^b[3])&(f[1]^f[2])
											      ^(d[2]^d[3])&(f[1]^f[2])^(a[2]^a[3])&(p[1]^p[2])^(d[2]^d[3])&(p[1]^p[2])
											      ^(b[2]^b[3])&(q[1]^q[2])^(c[2]^c[3])&(q[1]^q[2])^(d[2]^d[3])&(q[1]^q[2])^d[1]^q[1];

											g1[1]=(a[0]^a[2])&(e[0]^e[3])^(c[0]^c[2])&(e[0]^e[3])^(d[0]^d[2])&(e[0]^e[3])
											      ^(b[0]^b[2])&(f[0]^f[3])^(c[0]^c[2])&(f[0]^f[3])^(a[0]^a[2])&(p[0]^p[3])
											      ^(b[0]^b[2])&(p[0]^p[3])^(c[0]^c[2])&(p[0]^p[3])^(d[0]^d[2])&(p[0]^p[3])
											      ^(a[0]^a[2])&(q[0]^q[3])^(c[0]^c[2])&(q[0]^q[3])^b[0]^f[0]^d[0]^q[0];
											g2[1]=(b[0]^b[2])&(e[0]^e[3])^(c[0]^c[2])&(e[0]^e[3])^(a[0]^a[2])&(f[0]^f[3])
											      ^(b[0]^b[2])&(f[0]^f[3])^(d[0]^d[2])&(f[0]^f[3])^(a[0]^a[2])&(p[0]^p[3])
											      ^(c[0]^c[2])&(p[0]^p[3])^(b[0]^b[2])&(q[0]^q[3])^(d[0]^d[2])&(q[0]^q[3])^a[0]^e[0]
											      ^c[0]^p[0];
											g3[1]=(a[0]^a[2])&(e[0]^e[3])^(b[0]^b[2])&(e[0]^e[3])^(c[0]^c[2])&(e[0]^e[3])
											      ^(d[0]^d[2])&(e[0]^e[3])^(a[0]^a[2])&(f[0]^f[3])^(c[0]^c[2])&(f[0]^f[3])
											      ^(a[0]^a[2])&(p[0]^p[3])^(b[0]^b[2])&(p[0]^p[3])^(c[0]^c[2])&(p[0]^p[3])
											      ^(a[0]^a[2])&(q[0]^q[3])^(d[0]^d[2])&(q[0]^q[3])^c[0]^p[0]^d[0]^q[0];
											g4[1]=(a[0]^a[2])&(e[0]^e[3])^(c[0]^c[2])&(e[0]^e[3])^(b[0]^b[2])&(f[0]^f[3])
											      ^(d[0]^d[2])&(f[0]^f[3])^(a[0]^a[2])&(p[0]^p[3])^(d[0]^d[2])&(p[0]^p[3])
											      ^(b[0]^b[2])&(q[0]^q[3])^(c[0]^c[2])&(q[0]^q[3])^(d[0]^d[2])&(q[0]^q[3])^d[0]^q[0];

											g1[2]=(a[1]^a[3])&(e[0]^e[3])^(c[1]^c[3])&(e[0]^e[3])^(d[1]^d[3])&(e[0]^e[3])
											      ^(b[1]^b[3])&(f[0]^f[3])^(c[1]^c[3])&(f[0]^f[3])^(a[1]^a[3])&(p[0]^p[3])
											      ^(b[1]^b[3])&(p[0]^p[3])^(c[1]^c[3])&(p[0]^p[3])^(d[1]^d[3])&(p[0]^p[3])
											      ^(a[1]^a[3])&(q[0]^q[3])^(c[1]^c[3])&(q[0]^q[3])^b[3]^f[3]^d[3]^q[3];
											g2[2]=(b[1]^b[3])&(e[0]^e[3])^(c[1]^c[3])&(e[0]^e[3])^(a[1]^a[3])&(f[0]^f[3])
											      ^(b[1]^b[3])&(f[0]^f[3])^(d[1]^d[3])&(f[0]^f[3])^(a[1]^a[3])&(p[0]^p[3])
											      ^(c[1]^c[3])&(p[0]^p[3])^(b[1]^b[3])&(q[0]^q[3])^(d[1]^d[3])&(q[0]^q[3])^a[3]^e[3]
											      ^c[3]^p[3];
											g3[2]=(a[1]^a[3])&(e[0]^e[3])^(b[1]^b[3])&(e[0]^e[3])^(c[1]^c[3])&(e[0]^e[3])
											      ^(d[1]^d[3])&(e[0]^e[3])^(a[1]^a[3])&(f[0]^f[3])^(c[1]^c[3])&(f[0]^f[3])
											      ^(a[1]^a[3])&(p[0]^p[3])^(b[1]^b[3])&(p[0]^p[3])^(c[1]^c[3])&(p[0]^p[3])
											      ^(a[1]^a[3])&(q[0]^q[3])^(d[1]^d[3])&(q[0]^q[3])^c[3]^p[3]^d[3]^q[3];
											g4[2]=(a[1]^a[3])&(e[0]^e[3])^(c[1]^c[3])&(e[0]^e[3])^(b[1]^b[3])&(f[0]^f[3])
											      ^(d[1]^d[3])&(f[0]^f[3])^(a[1]^a[3])&(p[0]^p[3])^(d[1]^d[3])&(p[0]^p[3])
											      ^(b[1]^b[3])&(q[0]^q[3])^(c[1]^c[3])&(q[0]^q[3])^(d[1]^d[3])&(q[0]^q[3])^d[3]^q[3];

											g1[3]=(a[0]^a[1])&(e[1]^e[2])^(c[0]^c[1])&(e[1]^e[2])^(d[0]^d[1])&(e[1]^e[2])
											      ^(b[0]^b[1])&(f[1]^f[2])^(c[0]^c[1])&(f[1]^f[2])^(a[0]^a[1])&(p[1]^p[2])
											      ^(b[0]^b[1])&(p[1]^p[2])^(c[0]^c[1])&(p[1]^p[2])^(d[0]^d[1])&(p[1]^p[2])
											      ^(a[0]^a[1])&(q[1]^q[2])^(c[0]^c[1])&(q[1]^q[2])^b[2]^f[2]^d[2]^q[2];
											g2[3]=(b[0]^b[1])&(e[1]^e[2])^(c[0]^c[1])&(e[1]^e[2])^(a[0]^a[1])&(f[1]^f[2])
											      ^(b[0]^b[1])&(f[1]^f[2])^(d[0]^d[1])&(f[1]^f[2])^(a[0]^a[1])&(p[1]^p[2])
											      ^(c[0]^c[1])&(p[1]^p[2])^(b[0]^b[1])&(q[1]^q[2])^(d[0]^d[1])&(q[1]^q[2])^a[2]^e[2]
											      ^c[2]^p[2];
											g3[3]=(a[0]^a[1])&(e[1]^e[2])^(b[0]^b[1])&(e[1]^e[2])^(c[0]^c[1])&(e[1]^e[2])
											      ^(d[0]^d[1])&(e[1]^e[2])^(a[0]^a[1])&(f[1]^f[2])^(c[0]^c[1])&(f[1]^f[2])
											      ^(a[0]^a[1])&(p[1]^p[2])^(b[0]^b[1])&(p[1]^p[2])^(c[0]^c[1])&(p[1]^p[2])
											      ^(a[0]^a[1])&(q[1]^q[2])^(d[0]^d[1])&(q[1]^q[2])^c[2]^p[2]^d[2]^q[2];
											g4[3]=(a[0]^a[1])&(e[1]^e[2])^(c[0]^c[1])&(e[1]^e[2])^(b[0]^b[1])&(f[1]^f[2])
											      ^(d[0]^d[1])&(f[1]^f[2])^(a[0]^a[1])&(p[1]^p[2])^(d[0]^d[1])&(p[1]^p[2])
											      ^(b[0]^b[1])&(q[1]^q[2])^(c[0]^c[1])&(q[1]^q[2])^(d[0]^d[1])&(q[1]^q[2])^d[2]^q[2];

											//the first stage of the inverter
											h11[0]=inv11(g2,g3,g4)^inv11(g1,g3,o)^inv11(o,o,g3);
											h12[0]=inv11(g1,g3,g4)^inv11(g2,g3,o)^inv11(g2,g4,o);
											h13[0]=inv11(g1,g4,g2)^inv11(g1,g3,o)^inv11(o,o,g1);
											h14[0]=inv11(g1,g3,g2)^inv11(g1,g4,o)^inv11(g2,g4,o);

											h11[1]=inv12(g2,g3,g4)^inv12(g1,g3,o)^inv12(o,o,g3);
											h12[1]=inv12(g1,g3,g4)^inv12(g2,g3,o)^inv12(g2,g4,o);
											h13[1]=inv12(g1,g4,g2)^inv12(g1,g3,o)^inv12(o,o,g1);
											h14[1]=inv12(g1,g3,g2)^inv12(g1,g4,o)^inv12(g2,g4,o);

											//the second stage of the inverter
											h21[0]=h11[0]^inv21(g2,g3,g4)^inv21(g1,g3,o)^inv21(o,o,g3);
											h22[0]=h12[0]^inv21(g1,g3,g4)^inv21(g2,g3,o)^inv21(g2,g4,o);
											h23[0]=h13[0]^inv21(g1,g4,g2)^inv21(g1,g3,o)^inv21(o,o,g1);
											h24[0]=h14[0]^inv21(g1,g3,g2)^inv21(g1,g4,o)^inv21(g2,g4,o);

											h21[1]=h11[1]^inv22(g2,g3,g4)^inv22(g1,g3,o)^inv22(o,o,g3);
											h22[1]=h12[1]^inv22(g1,g3,g4)^inv22(g2,g3,o)^inv22(g2,g4,o);
											h23[1]=h13[1]^inv22(g1,g4,g2)^inv22(g1,g3,o)^inv22(o,o,g1);
											h24[1]=h14[1]^inv22(g1,g3,g2)^inv22(g1,g4,o)^inv22(g2,g4,o);

											h[0]=h21[0]<<3 |h22[0]<<2 |h23[0]<<1|h24[0];
											h[1]=h21[1]<<3 |h22[1]<<2 |h23[1]<<1|h24[1];

											//the 4-share input is reduced to 2 shares
											u[0]=(a[1]^a[0])<<3|(b[1]^b[0])<<2 |(c[1]^c[0])<<1|(d[1]^d[0]);
											u[1]=(a[3]^a[2])<<3|(b[3]^b[2])<<2 |(c[3]^c[2])<<1|(d[3]^d[2]);

											v[0]=(e[1]^e[2])<<3|(f[1]^f[2])<<2 |(p[1]^p[2])<<1|(q[1]^q[2]);
											v[1]=(e[3]^e[0])<<3|(f[3]^f[0])<<2 |(p[3]^p[0])<<1|(q[3]^q[0]);

											//the first input share as random bits
											r1=(a[0])<<3|(b[0])<<2 |(c[0])<<1|(d[0]);
											r2=(e[0])<<3|(f[0])<<2 |(p[0])<<1|(q[0]);

											//the sharing of two gf2^4 multipliers in stage 4
											y1[0]=mul(u[0],h[0]);
											y1[1]=mul(u[0],h[1])^r1;
											y1[2]=mul(u[1],h[0])^r1;
											y1[3]=mul(u[1],h[1]);

											y2[0]=mul(v[0],h[0]);
											y2[1]=mul(v[0],h[1])^r2;
											y2[2]=mul(v[1],h[0])^r2;
											y2[3]=mul(v[1],h[1]);

											y[0]=(y1[0]^y1[1])<<4|(y2[0]^y2[1]);
											y[1]=(y1[2]^y1[3])<<4|(y2[2]^y2[3]);


											i=u[0]<<12 |u[1]<<8 |h[0]<<4|h[1];  //check the uniformity of the input of multiplier1 in stage 4
											//i=v[0]<<12 |v[1]<<8 |h[0]<<4|h[1];  //check the uniformity of the input of multiplier2 in stage 4
											//i=y[0]<<8 |y[1];  //check the uniformity of the output of the Sbox
											tt[i]=tt[i]+1;
										}
									}
								}
							}
						}
					}
				}
			}
			for (j = 0; j< 65536; j++) {
				if(tt[j]==65536) { //the number of times that a output g1,g2,g3,g4 occurs for any given input should be 2^8(4-1)/2^4(4-1)=4096
					z=z+1;//counter
				}
				if(!(tt[j]==0|tt[j]==65536)) {  //if there is a number which not equals 4096, the sharing functions are not uniform
					printf("The sharing functions are not uniform");
				}
			}
			//printf("%5d",z);
		}
	}
	printf("The sharing functions are uniform");
	return(0);
}

